# LVM字节码指令集概述

本文档将对LVM中的字节码指令集进行一个概括性的描述。具体每一个指令的编号，参数和具体操作都将在另一个文档中详细表述。

## 字节码指令

字节码指令是LVM运行的最小单元。LVM会根据`.lvm`中字节码指令的次序运行。字节码之所以称之为字节码，是因为其及其参数都是以一个个字节的形式存储的。但是在描述的时候采用了一些便于理解的特定符号和英语单词，这些都不会存储在字节码指令中。

如非特殊说明，LVM中的所有指令都是 **原子性** 的，也就是说，要不就完成操作，要不就对现在的状态不进行任何改变。

## 数学相关指令

正如数据类型文档中所描述的，LVM中支持四种长度不同的数值类型：`int`,`long`,`float`,`double`。由于它们的长度或储存方式都不相同，因此对于每个数据类型，LVM都提供了一套完整的指令集。因此下面在描述它们的时候采用泛化的形式，不同数据类型通过特有的前缀进行区别。

- 所有数学类型：
  - `add` 加法
  - `sub` 减法
  - `mul` 乘法
  - `div` 除法
  - `rem` 取模
  - `neg` 取负

- 整数类型特有：
  - `shl`  左移位
  - `shr`  有符号右移位/算数右移位
  - `ushr` 无符号右移位/逻辑右移位
  - `and`  按位与
  - `or`   按位或
  - `xor`  按位异或

下面是每种数据类型都前缀：

| 数据类型                        | 前缀 |
| ------------------------------- | :--: |
| 32位有符号整数 `int`            | `i`  |
| 64位有符号整数`long`            | `l`  |
| 32位有符号单精度浮点数`float`   | `f`  |
| 64位有符号双精度浮点数 `double` | `d`  |

**关于右移操作**

（下面以`int`为例，以`>>`代表`ishr`，以`>>>`代表`iushr`，以`v1`代表被操作数，以`s`代表位移量）

1. `ishr`是算数右移，也就是在**数学上**正确的右移，即其结果一定为`v1/2^s`；`iushr`是逻辑右移，也就是在**逻辑上**正确的右移，即其结果就是`v1`二进制向右移动。
2. `ishr`是有符号右移，也就是使用原来数字的符号位来填充高位；`iushr`是无符号右移，也就是不管是正是负，都用`0`来填充高位。
3. 如果`v1`本身无符号限制（为非负数），那么`ishr`与`iushr`的效果相同。

例子（用8位二进制补码进行简化）：
-12      :    111101 00
-12 >>  2: 11 111101     => -3
-12 >>> 2: 00 111101     => 1073741821
         --^^-- 注意右移后空缺的高位